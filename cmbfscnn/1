# -*- coding: utf-8 -*-

import os
import sys
import numpy as np
import healpy as hp
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(BASE_DIR)
# import pysm
import astropy.units as u
import pysm3
# from pysm.nominal import models
# from pysm.common import convert_units

from . import get_power_sperctra as ps

def degrade_map(map_in, nside_in, nside_out):
    """Degrades and returns a map"""

    if nside_in == nside_out:
        return map_in

    map_out = []

    for i in range(map_in.shape[0]):
        map_i = map_in[i, :, :]

        alm_i = hp.map2alm(map_i)
        nside_out = self.Nside

        # Verificar si alm tiene varias componentes
        if alm_totali.ndim > 1:
            alm_T_total = alm_totali[0]  # Tomar la componente T
            alm_E_total = alm_totali[1]  # Tomar la componente E
            alm_B_total = alm_totali[2]  # Tomar la componente B
        else:
            raise ValueError("alm no tiene suficientes componentes para T, E y B")

        # Obtener lmax de la serie alm
        lmax_in_total = hp.Alm.getlmax(len(alm_T_total))
        lmax_out_total = min(lmax_in_total, 3 * nside_out - 1)  # Limitado por nside_out

        # Obtener funciones de ventana de píxeles
        pixwin_2048 = hp.pixwin(nside_in, pol=True)  # Incluye T, E y B
        pixwin_512 = hp.pixwin(nside_out, pol=True)  # Incluye T, E y B

        # Degradar alm para T, E y B
        alm_degraded_T_total = hp.almxfl(alm_T_total, 1.0 / pixwin_2048[0][: lmax_in_total + 1])  # Remueve efecto de nside=2048
        alm_out_T_total = hp.almxfl(alm_degraded_T_total, pixwin_512[0][: lmax_out_total + 1])    # Aplica efecto de nside=512

        alm_degraded_E_total = hp.almxfl(alm_E_total, 1.0 / pixwin_2048[1][: lmax_in_total + 1])  # Remueve efecto de nside=2048
        alm_out_E_total = hp.almxfl(alm_degraded_E_total, pixwin_512[1][: lmax_out_total + 1])    # Aplica efecto de nside=512

        alm_degraded_B_total = hp.almxfl(alm_B_total, 1.0 / pixwin_2048[1][: lmax_in_total + 1])  # Remueve efecto de nside=2048
        alm_out_B_total = hp.almxfl(alm_degraded_B_total, pixwin_512[1][: lmax_out_total + 1])    # Aplica efecto de nside=512

        # Convertir alm a un único mapa combinando T, E y B en nside=512
        total_1.append(hp.alm2map([alm_out_T_total, alm_out_E_total, alm_out_B_total], nside=nside_out, pol=True))

    return total


def process_sky(sky_fg, cmb, freqs, nside_fg, nside_exp, nside_out, beam=None):
    """
    Generate total sky signal (CMB + foregrounds) with proper degradation and beam.
    """

    # ---- 1. Generate foreground emission ----
    foreground = sky_fg.get_emission(freqs * u.GHz).value.astype(np.float32)

    # ---- 2. Match foreground resolution to experiment resolution ----
    if nside_fg != nside_exp:
        print(f"Degrading foreground from {nside_fg} to {nside_exp}")
        foreground = np.array([degrade_map(f, nside_fg, nside_exp) for f in foreground])

    # ---- 3. Combine with CMB ----
    total = foreground + cmb

    # ---- 4. Match total and CMB to desired output Nside ----
    if nside_exp != nside_out:
        print(f"Degrading total and CMB from {nside_exp} to {nside_out}")
        total = np.array([degrade_map(t, nside_exp, nside_out) for t in total])
        cmb = np.array([degrade_map(c, nside_exp, nside_out) for c in cmb])


    # ---- 5. Convert units ----
    # cmb = convert_unit(cmb, freqs, "uK_RJ", out_unit)
    # total = convert_unit(total, freqs, "uK_RJ", out_unit)

        # ---- 6. Apply beam smoothing ----
    if beam is not None:
        cmb = beam(cmb)
        total = beam(total)

    return cmb.astype(np.float32), total.astype(np.float32)


def c2_mode(nside):
    return [{
        'model' : 'taylens',
        'nside' : nside,
        'cmb_seed' : 1111,
        'delens': False,
        'output_unlens': False
        }]


def c2_unlens_mode(nside):
    return [{
        'model' : 'taylens',
        'nside' : nside,
        'cmb_seed' : 1111,
        'delens': False,
        'output_unlens':True
        }]


def get_specificRandn(n, mu, sigma, range_min, range_max):
    randn = np.random.randn(n) * sigma + mu
    choose_1 = np.where(randn>=range_min)
    randn = randn[choose_1]
    choose_2 = np.where(randn<=range_max)
    randn = randn[choose_2]
    return randn


class Get_data(object):
    def __init__(self, Nside,  config_random = {}, freqs=None,  using_beam = False,
                  beam = None, out_unit = None):
        self.Nside = Nside
        self.Nside_fg = None
        self.freqs = freqs
        self.using_beam = using_beam
        self.beam = beam
        self.out_unit = out_unit # the unit of output, 'K_CMB', 'Jysr', 'uK_RJ';
        # Default unit of signals is 'uK_RJ'; Default unit of noise may be 'K_CMB'
        self.config_random = config_random

    def data(self):
        # random can be 'fixed', fix cosmological paramaters

        cmb_specs = ps.ParametersSampling(random=self.config_random['Random_types_of_cosmological_parameters'], spectra_type='unlensed_scalar')
        sky = pysm3.Sky(nside=self.Nside, preset_strings=["s1", "d1", "a2"])
        self.Nside_fg = 2048
        s1 = sky.components[0]
        d1 = sky.components[1]
        a2 = sky.components[2]
        # s1 = models("s1", self.Nside)
        # d1 = models("d1", self.Nside)
        # a2 = models("a2", self.Nside)
        c2 = c2_mode(self.Nside)
        c2[0]['cmb_specs'] = cmb_specs
        c1_seed = self.config_random['cmb_seed']
        c2[0]['cmb_seed'] = c1_seed

        c2_unlens = c2_unlens_mode(self.Nside)
        cmb_spe = cmb_specs.copy()
        c2_unlens[0]['cmb_specs'] = cmb_spe
        c2_unlens[0]['cmb_seed'] = c1_seed

        # TODO: Implement randomization

        sky_config_cmb = ["c2"]
        sky_config_fg = ['s1', 'd1', 'a2']

        sky_fg = pysm3.Sky(nside = self.Nside_fg, preset_strings = sky_config_fg)  #
        sky_cmb = pysm3.Sky(nside = self.Nside, preset_strings = sky_config_cmb)  #

        total = sky.get_emission(self.freqs * u.GHz)
        total = total.astype(np.float32)

        cmb = sky_cmb.get_emission(self.freqs * u.GHz)
        cmb = cmb.astype(np.float32)

        if self.using_beam:
            cmb = self.data_proce_beam(cmb,using_beam_1=self.using_beam, beam_1=self.beam)
            cmb = sky_cmb.get_emission(self.freqs * u.GHz)
            cmb = cmb.astype(np.float32)

        # if not self.out_unit == None:
        #     Uc_signal = np.array(convert_units("uK_RJ", self.out_unit, self.freqs))
        #     if not len(self.freqs)>1:  # one frequence
        #         cmb = cmb * Uc_signal[:, None, None]
        #         total = total * Uc_signal[:, None, None]
        #     else:
        #         cmb = cmb * Uc_signal[:, None, None]
        #         total = total * Uc_signal[:, None, None]

        fg = sky_fg.get_emission(self.freqs * u.GHz)
        fg = fg.value.astype(np.float32)


        # total = self.data_proce_beam(total, using_beam_1=self.using_beam, beam_1=self.beam)
        cmb, total = process_sky(sky_fg = sky_fg,
                                 cmb = cmb,
                                 freqs = self.freqs,
                                 nside_fg = self.Nside_fg,
                                 nside_exp = 512,
                                 nside_out = self.Nside,
                                 beam = self.beam)
        return cmb, total

    def data_proce_beam(self, map_da,using_beam_1=False, beam_1=None):
        if using_beam_1:
            beam = beam_1
            map_n = np.array(
                [hp.smoothing(m, fwhm=np.pi / 180. * b / 60., verbose=False) for (m, b) in zip(map_da, beam)])
        else:
            map_n = map_da
            # dd = map_new
        return map_n

    def noiser(self, Sens, is_half_split_map = True):
        """Calculate white noise maps for given sensitivities.  Returns noise, and noise maps at the given nside in (T, Q, U). Input
        sensitivities are expected to be in uK_CMB amin for the rest of
        PySM.

        :param is_half_split_map: If it is an half-split map, the noise level will increase by sqrt(2) times

        """
        # solid angle per pixel in amin2
        npix = hp.nside2npix(self.Nside)
        # solid angle per pixel in amin2, Note!!!!!
        pix_amin2 = 4. * np.pi / float(hp.nside2npix(self.Nside)) * (180. * 60. / np.pi) ** 2
        """sigma_pix_I/P is std of noise per pixel. It is an array of length
        equal to the number of input maps."""
        if is_half_split_map:
            sigma_pix_I = np.sqrt(Sens ** 2 / pix_amin2)*np.sqrt(2)
        else:
            sigma_pix_I = np.sqrt(Sens ** 2 / pix_amin2)
        noise = np.random.randn(len(Sens), 3,npix)
        noise *= sigma_pix_I[:, None,None]
        if not self.out_unit ==None:
            Uc_noise = np.array(convert_units("uK_CMB", self.out_unit, self.freqs))
            noise = noise * Uc_noise[:, None, None]
        return noise.astype(np.float32)
